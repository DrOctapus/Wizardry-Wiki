本页面将介绍如何让你自己编写更多[[法术]]加入到游戏内。

## 准备
- 一个添加法术的附属模组。你需要先完成[[开发附属模组]]的所有步骤。 
- 了解关于 JSON 的基础知识。 
- 对法术足够的想象力！ 限制你的只有你的想象力和编程能力, 尽管后者可以通过不断地训练提高 - 如果你有困难，可以到MOD社区求助。

## 编写法术类
首先，你需要编写一个新的类来存放你的法术，这是给你运行代码的地方。新增一个类作为`Spell`的拓展。你可以在`electroblob.wizardry.spell`包内找到`Spell`类。 我为 Javadoc 写了一个完整的注释去说明类中的方法和字段，我推荐你去认真阅读它们。

在这个类中新建一个没有参数的构造函数（constructor），并且调用在`Spell`类中的超级构造函数（super constructor）。`Spell`中有**两个**超级构造函数，你需要确保自己添加了一个`modID`附加参数。接下来你需要给超级构造函数传递一些参数，这是该函数关于法术的参数信息：

- `modID` 你的附属模组的 **模组ID**。这个是便于巫术学模组区分哪些法术是来自附属模组的。
- `name` 未揭秘时你的法术的名称，名称要求是全小写字母，并在单词与单词间加上下划线。
- `action` 即 `EnumAction`, 就是在施法时播放的动画效果。
- `isContinuous` 设定为True则玩家需要长按鼠标才能施法，设定为false则只需要按下一次即可。

接下来你需要做的事情就是重写`Spell`里面第一个的`cast(...)`执行方法。这个控制着你的法术将会如何生效，每当 _玩家_ 释放这个法术的时候 (关于如何让巫师和其它实体释放你的这个咒语的方法，请往下看)。接下来你就要开始编写如何让这些法术起作用的执行方法的代码。你的法术可以是有关任何方面的，所以尽情的发挥你的想象力吧！Forge的强大超乎你的想象，你也可以参照一下原有的法术来尝试着进行编写。

`cast(...)` 执行方法将返回一个 `boolean` 来告诉开发人员巫师能否正常释放这个法术。如若正常释放，则返回true，如若不能，则返回false。比如当使用[[强效治疗]]这个法术时，如果法术成功治疗了玩家，则返回true，如果施法过程中出现错误或者玩家处于满血状态，则返回false。另外，返回true的时候也意味着 —— 法杖消耗了魔力值或是消耗了对应法术的卷轴。

> 在 `electroblob.wizardry.util` 有一个名为 `WizardryUtilities` 的类，你很快就会发现这个类是很有用的 —— 我把这个类设定为我放置模组里各种执行方法的地方，其中的一些执行方法也许也能为你提供灵感。特别是，它包含方块、坐标、实体、动画等的处理方法。

## 创建法术的 JSON 文件

从模组4.2版本起, 所有的法术都有了其对应的JSON文件，而这些文件被我放在了 `assets/[modid]/spells` 路径中（以前我都是将这些法术写死在编码里的）。因此你也需要为你的法术创建一个JSON文件以便这些法术能被正常的读取。详见 [[法术属性文件]] 中关于如何编写此类文件的说明。并且暂时将 `base_properties` 对象留空 —— 便于你稍后添加关于这个法术的具体属性。

> 游戏加载过程中，巫术学模组将自动读取每一个法术的属性文件，如果有任何一个文件出现错误或者丢失，模组就会向控制台输出警告。

## 注册你的法术

为了使你的法术能够出现在游戏中，你需要通过类似方块和物品注册ID的方式为它也注册一个。就如方块和物品一样，每一个法术都有一个对应的实例。在Forge 1.10及更高版本中, 这是通过 **registry events** 来完成的。 To register your spell using registry events, make an event handler (or open up an existing one) and make a new method that subscribes to `RegistryEvent.Register<Spell>` (see the Forge documentation on [events](https://mcforge.readthedocs.io/en/latest/events/intro/) if you don't know how). Inside that method, create a new instance of your spell class and register it using `event.getRegistry().register(spell)`. The method should now look something like this:

```java
@SubscribeEvent
public static void register(RegistryEvent.Register<Spell> event){

    event.getRegistry().register(new YourSpell());

}
```

> The older `GameRegistry.register(...)` methods still exist in Forge, but because of how wizardry processes the registered spells, these **will not work** for spells - you must use registry events.

That's it for the required stuff! If you load up the game, you should now see a spell book and (if your spell isn't continuous) a scroll for your spell in the Spells tab of the creative mode inventory, and with any luck you'll be able to cast your spell in-game.

## Making your spell look nice

As you probably know, all spells in wizardry have an icon which appears in their spell book and on the spell HUD. You'll need to draw an icon for your spell, which should be a pictorial representation of your spell. I suggest starting with the blank icon, which can be found in `assets/wizardry/textures/spells/none.png`. Edit this with an image editing program (I use GIMP) and save your finished icon as `[your spell name].png` in `resources/[your mod ID]/assets/textures/spells`, where [your spell name] is the unlocalised name you gave your spell in its constructor.

You will need to add **localisations** for the spell to give it a nice, readable name and description. These should be put in **your lang file**, located in `assets/[your mod ID]/lang/en_US.lang`. The syntax is `spell.[unlocalised name]` for the spell name and `spell.[unlocalised name].desc` for the description.

## Making wizards cast your spell

Making [[wizards|Wizard]] cast your spell is fairly simple once you have written the code for players casting it. This time, you'll need to override the _second_ `cast(...)` method in `Spell`. You'll notice a couple of differences between this method and the player method:
- The `caster` argument is an `EntityLiving` instead of an `EntityPlayer`. This is because this method deals with non-player entities casting the spell.
- There is an additional `target` argument of type `EntityLivingBase`. This is the target that the NPC aimed at when it cast the spell.

Other than that, the method works in exactly the same way. I suggest copying the code from the other `cast(...)` method and adapting it to make it work with non-player entities - you might not have to do anything, or you might have to change it completely, depending on the spell.

You'll also need to override `Spell.canBeCastByNPCs()` to return true to allow wizards to spawn with your spell equipped.

## Standard spell superclasses

Since many spells are similar to each other, there is a set of abstract superclasses for common types of spell. These can greatly reduce the code required to make a spell work, and make sure all spells of similar types behave in a standard way.

Wizardry has the following standard spell classes built-in:

- `SpellArrow`: for spells that shoot projectiles extending `EntityMagicArrow` (see [[Adding Entities]])
- `SpellBuff`: for spells that apply one or more potion effects to their caster
- `SpellConjuration`: for spells that conjure items (normally these items implement `IConjuredItem`)
- `SpellConstruct`: for spells that summon an `EntityMagicConstruct` (see [[Adding Entities]]) at the caster's position
- `SpellConstructRanged`: for spells that summon an `EntityMagicConstruct` (see [[Adding Entities]]) at the position aimed at
- `SpellProjectile`: for spells that shoot projectiles extending `EntityMagicProjectile` (see [[Adding Entities]])
- `SpellMinion`: for spells that summon entities implementing `ISummonedCreature` (see [[Adding Entities]])
- `SpellRay`: for spells that use raytracing. This includes instant 'bolt' spells like [[poison]] and continuous 'stream' spells like [[flame ray]]

Some of these classes are _parametrised_, meaning a type parameter should be supplied when extending them. This is usually the type of entity the spell summons/shoots.

## Further information

That covers the basics of adding your own spells to wizardry, but it's likely that at some point you'll want to do something that requires more than just a spell class. Fortunately, wizardry already has some classes that can help you:

- If you want to add custom entities for your spell, there are some base classes you can use for that. See [[Adding Entities]] for more details.
- You might also want to add particle effects to your spells. Vanilla Minecraft has a fair few itself, but there are also some that are added by wizardry. To spawn these, use `Wizardry.proxy.spawnParticle(...)`, and pass the `WizardryParticleType` that you want to spawn into the method parameters.
- `WandHelper` in `electroblob.wizardry` might also come in handy if you plan to interact with wand data at all.
