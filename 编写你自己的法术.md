本页面将介绍如何让你自己编写更多[[法术]]加入到游戏内。

## 准备
- 一个添加法术的附属模组。你需要先完成[[开发附属模组]]的所有步骤。 
- 了解关于 JSON 的基础知识。 
- 对法术足够的想象力！ 限制你的只有你的想象力和编程能力, 尽管后者可以通过不断地训练提高 - 如果你有困难，可以到MOD社区求助。

## 编写法术类
首先，你需要编写一个新的类来存放你的法术，这是给你运行代码的地方。新增一个类作为`Spell`的拓展。你可以在`electroblob.wizardry.spell`包内找到`Spell`类。 我为 Javadoc 写了一个完整的注释去说明类中的方法和字段，我推荐你去认真阅读它们。

在这个类中新建一个没有参数的构造函数（constructor），并且调用在`Spell`类中的超级构造函数（super constructor）。`Spell`中有**两个**超级构造函数，你需要确保自己添加了一个`modID`附加参数。接下来你需要给超级构造函数传递一些参数，这是该函数关于法术的参数信息：

- `modID` 你的附属模组的 **模组ID**。这个是便于巫术学模组区分哪些法术是来自附属模组的。
- `name` 未揭秘时你的法术的名称，名称要求是全小写字母，并在单词与单词间加上下划线。
- `action` 即 `EnumAction`, 就是在施法时播放的动画效果。
- `isContinuous` 设定为True则玩家需要长按鼠标才能施法，设定为false则只需要按下一次即可。

接下来你需要做的事情就是重写`Spell`里面第一个的`cast(...)`执行方法。这个控制着你的法术将会如何生效，每当 _玩家_ 释放这个法术的时候 (关于如何让巫师和其它实体释放你的这个咒语的方法，请往下看)。接下来你就要开始编写如何让这些法术起作用的执行方法的代码。你的法术可以是有关任何方面的，所以尽情的发挥你的想象力吧！Forge的强大超乎你的想象，你也可以参照一下原有的法术来尝试着进行编写。

`cast(...)` 执行方法将返回一个 `boolean` 来告诉开发人员巫师能否正常释放这个法术。如若正常释放，则返回true，如若不能，则返回false。比如当使用[[强效治疗]]这个法术时，如果法术成功治疗了玩家，则返回true，如果施法过程中出现错误或者玩家处于满血状态，则返回false。另外，返回true的时候也意味着 —— 法杖消耗了魔力值或是消耗了对应法术的卷轴。

> 在 `electroblob.wizardry.util` 有一个名为 `WizardryUtilities` 的类，你很快就会发现这个类是很有用的 —— 我把这个类设定为我放置模组里各种执行方法的地方，其中的一些执行方法也许也能为你提供灵感。特别是，它包含方块、坐标、实体、动画等的处理方法。

## 创建法术的 JSON 文件

从模组4.2版本起, 所有的法术都有了其对应的JSON文件，而这些文件被我放在了 `assets/[modid]/spells` 路径中（以前我都是将这些法术写死在编码里的）。因此你也需要为你的法术创建一个JSON文件以便这些法术能被正常的读取。详见 [[法术属性文件]] 中关于如何编写此类文件的说明。并且暂时将 `base_properties` 对象留空 —— 便于你稍后添加关于这个法术的具体属性。

> 游戏加载过程中，巫术学模组将自动读取每一个法术的属性文件，如果有任何一个文件出现错误或者丢失，模组就会向控制台输出警告。

## 注册你的法术

为了使你的法术能够出现在游戏中，你需要通过类似方块和物品注册ID的方式为它也注册一个。就如方块和物品一样，每一个法术都有一个对应的实例。在Forge 1.10及更高版本中, 这是通过 **注册事件** 来完成的。为你的法术注册之前, 先创建一个事件句柄(或者选中一个现有的) 和一个新的执行方法，将两者注册到： `RegistryEvent.Register<法术名>` (如果你不知道怎么注册的话，你也可以查看Forge给出的 [帮助文档](https://mcforge.readthedocs.io/en/latest/events/intro/)。)。在新创建的执行方法中，创建你的 法术 类的一个新实例，并使用 `event.getRegistry().register(法术名)`进行注册。执行方法的编写大致如下：

```java
@SubscribeEvent
public static void register(RegistryEvent.Register<Spell> event){

    event.getRegistry().register(new YourSpell());

}
```

> 旧的 `GameRegistry.register(...)` 执行方法残留在Forge中，但由于巫术学模组本身所使用的注册法术的方法与之不同，因此旧的注册执行方法将不会起到任何作用 —— 你必须使用上面的方法对你的法术进行注册。

注册对于法术来说是必要的！如果你成功注册了法术并为其编写了内容的话，你现在在创造模式分类栏里面的法术书堆里面大概就能看到你新注册的法术的法术书了，如果你幸运值拉满的话，你现在就能正常释放你新写的法术了。

## 为你的法术润色

如你所见，模组里面的每一个法术都有一个对应的法术图标。所以你需要为你的法术绘制一个图标，这个图标应该和你的法术的实际效果有关。我建议你从一个空白透明的图标开始画起，你可以在 `assets/wizardry/textures/spells/none.png` 路径中找到空白图标。并在图像编辑软件中开始绘制这个图标 (作者用的是 GIMP) 然后将你绘制好的图标保存为png格式并重命名为 `[你法术的英文名].png` 然后将其放到 `resources/[your mod ID]/assets/textures/spells` 路径中。

同样你也需要为你的法术进行 **本地化设置** 才能给你的法术设置一个好的可读的法术名和法术描述。这些都应该被放入你的 **语言文件** 中，路径为 `assets/[你的模组ID]/lang/en_US.lang`。编写的标准语法是 `spell.[英文法术名]` 设置为法术名 `spell.[英文法术名].desc` 设置为法术描述。

## 让巫师也能施展你的法术

只要你一旦能让玩家释放你的法术，那么让[[巫师]]也能施展你的法术就不是问题了。这一次，你就需要_重新_写一次 `Spell` 的 `cast(...)` 执行方法。你会注意到这个方法和让玩家释放的方法也一些细微的差别：
- The `caster` argument is an `EntityLiving` instead of an `EntityPlayer`. This is because this method deals with non-player entities casting the spell.
- There is an additional `target` argument of type `EntityLivingBase`. This is the target that the NPC aimed at when it cast the spell.

Other than that, the method works in exactly the same way. I suggest copying the code from the other `cast(...)` method and adapting it to make it work with non-player entities - you might not have to do anything, or you might have to change it completely, depending on the spell.

You'll also need to override `Spell.canBeCastByNPCs()` to return true to allow wizards to spawn with your spell equipped.

## Standard spell superclasses

Since many spells are similar to each other, there is a set of abstract superclasses for common types of spell. These can greatly reduce the code required to make a spell work, and make sure all spells of similar types behave in a standard way.

Wizardry has the following standard spell classes built-in:

- `SpellArrow`: for spells that shoot projectiles extending `EntityMagicArrow` (see [[Adding Entities]])
- `SpellBuff`: for spells that apply one or more potion effects to their caster
- `SpellConjuration`: for spells that conjure items (normally these items implement `IConjuredItem`)
- `SpellConstruct`: for spells that summon an `EntityMagicConstruct` (see [[Adding Entities]]) at the caster's position
- `SpellConstructRanged`: for spells that summon an `EntityMagicConstruct` (see [[Adding Entities]]) at the position aimed at
- `SpellProjectile`: for spells that shoot projectiles extending `EntityMagicProjectile` (see [[Adding Entities]])
- `SpellMinion`: for spells that summon entities implementing `ISummonedCreature` (see [[Adding Entities]])
- `SpellRay`: for spells that use raytracing. This includes instant 'bolt' spells like [[poison]] and continuous 'stream' spells like [[flame ray]]

Some of these classes are _parametrised_, meaning a type parameter should be supplied when extending them. This is usually the type of entity the spell summons/shoots.

## Further information

That covers the basics of adding your own spells to wizardry, but it's likely that at some point you'll want to do something that requires more than just a spell class. Fortunately, wizardry already has some classes that can help you:

- If you want to add custom entities for your spell, there are some base classes you can use for that. See [[Adding Entities]] for more details.
- You might also want to add particle effects to your spells. Vanilla Minecraft has a fair few itself, but there are also some that are added by wizardry. To spawn these, use `Wizardry.proxy.spawnParticle(...)`, and pass the `WizardryParticleType` that you want to spawn into the method parameters.
- `WandHelper` in `electroblob.wizardry` might also come in handy if you plan to interact with wand data at all.
